var documenterSearchIndex = {"docs":
[{"location":"core/simulation/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"core/simulation/","page":"Simulations","title":"Simulations","text":"Simulation","category":"page"},{"location":"core/simulation/#Conductor.Simulation","page":"Simulations","title":"Conductor.Simulation","text":"Simulation(neuron::Conductor.AbstractCompartmentSystem; time, return_system)\n\n\nCompile and run a simulation of a single neuron or network of neurons for a specified duration, time.\n\nIf return_system == true, returns a simplified ODESystem instead.\n\n\n\n\n\n","category":"function"},{"location":"core/compartments/#compartments","page":"Compartments","title":"Compartments","text":"","category":"section"},{"location":"core/compartments/#Single-Compartments","page":"Compartments","title":"Single Compartments","text":"","category":"section"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"A CompartmentSystem is sufficient to model a simple neuron–either as an isopotential spherical neuron, or as a \"point\" neuron with no morphological geometry. At minimum, a CompartmentSystem will contain information about its intrinsic membrane currents and ionic gradients (i.e. equilibrium potentials). We define these by directly providing vectors of ConductanceSystem and EquilibriumPotential to the CompartmentSystem:","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"using Conductor, Unitful, ModelingToolkit, IfElse\nimport Unitful: mV, mS, cm\n\nVₘ = MembranePotential()\n\nnav_kinetics = [\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -40.0, 1.0, (0.1*(Vₘ + 40.0))/(1.0 - exp(-(Vₘ + 40.0)/10.0))),\n         4.0*exp(-(Vₘ + 65.0)/18.0), p = 3, name = :m)\n    Gate(AlphaBeta,\n         0.07*exp(-(Vₘ+65.0)/20.0),\n         1.0/(1.0 + exp(-(Vₘ + 35.0)/10.0)), name = :h)]\n\nkdr_kinetics = [\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -55.0, 0.1, (0.01*(Vₘ + 55.0))/(1.0 - exp(-(Vₘ + 55.0)/10.0))),\n         0.125 * exp(-(Vₘ + 65.0)/80.0),\n         p = 4, name = :n)]\n\n# Note: `IonChannel` is a convenience constructor that returns a `ConductanceSystem`\n@named NaV = IonChannel(Sodium, nav_kinetics, max_g = 120mS/cm^2) \n@named Kdr = IonChannel(Potassium, kdr_kinetics, max_g = 36mS/cm^2)\n@named leak = IonChannel(Leak, max_g = 0.3mS/cm^2)\n\nchannels = [NaV, Kdr, leak];\nreversals = Equilibria([Sodium => 50.0mV, Potassium => -77.0mV, Leak => -54.4mV])\n\ndynamics = HodgkinHuxley(Vₘ, channels, reversals)\n\n@named neuron = CompartmentSystem(dynamics)\n@assert length.((equations(neuron), states(neuron), parameters(neuron))) == (12,12,8) # hide\nneuron # hide","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"note: Note\nWe use IfElse.ifelse to handle discontinuities in the rate equations for Sodium and Potassium channel dynamics. In Julia v1.8+ Base.ifelse may be used directly without the need for an external dependency. ","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"In the case above, the CompartmentSystem constructor assumes a dimensionless geometry = Point(). The maximum magnitudes of the ion channel conductances, overlineg, have units of SpecificConductance (mS/cm²) that scale with the surface area of the compartment. However, when the geometry is a Point(), the CompartmentSystem ignores surface area scaling (internally, the area is fixed to 1.0). We can instead provide a <:Geometry object to describe the shape and size of the compartment:","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"import Unitful: µm\nsoma_shape = Sphere(radius = 20µm)\ngeo_dynamics = HodgkinHuxley(Vₘ, channels, reversals; geometry = soma_shape)\n@named neuron = CompartmentSystem(geo_dynamics)\n@assert length.((equations(neuron), states(neuron), parameters(neuron))) == (12,12,8); # hide\nnothing # hide","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"If we try to simulate the neuron we've modeled so far, the result isn't very interesting:","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"import Unitful: ms\nusing OrdinaryDiffEq, Plots\nsim = Simulation(neuron, time = 300ms)\nsolution = solve(sim, Rosenbrock23(), abstol=1e-3, reltol=1e-3, saveat=0.2)\nplot(solution; vars=[Vₘ])","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"The neuron isn't spontaneously active. To make the neuron produce spikes, we can write an equation for an electrode current and provide it to CompartmentSystem: ","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"import Unitful: µA, pA\n@named Iₑ = IonCurrent(NonIonic)\n\n# A 400 picoamp squarewave pulse when 100ms > t > 200ms\nelectrode_pulse = Iₑ ~ IfElse.ifelse(t > 100.0,\n                                     IfElse.ifelse(t < 200.0,\n                                                   ustrip(Float64, µA, 400pA),\n                                                   0.0),\n                                     0.0)\nstim_dynamics = HodgkinHuxley(Vₘ, channels, reversals;\n                              geometry = soma_shape,\n                              stimuli = [electrode_pulse])\n\n@named neuron_stim = CompartmentSystem(stim_dynamics)\n@assert length.((equations(neuron_stim), states(neuron_stim), parameters(neuron_stim))) == (13,13,8); # hide\nneuron_stim # hide","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"Putting it all together, our neuron simulation now produces a train of action potentials:","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"sim = Simulation(neuron_stim, time = 300ms)\nsolution = solve(sim, Rosenbrock23(), abstol=1e-3, reltol=1e-3, saveat=0.2)\nplot(solution; vars=[Vₘ])","category":"page"},{"location":"core/compartments/#Multiple-Compartments","page":"Compartments","title":"Multiple Compartments","text":"","category":"section"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"Neurons with multiple compartments are explicitly constructed by defining a MultiCompartmentTopology, a directed graph that is provided to MultiCompartmentSystem. Individual subcompartments are connected via add_junction!. By default, a junction between compartments is assumed to be symmetrical–the axial conductance from compartment A to B is the same value as from compartment B to A. However, if the conductance between compartments is asymmetric, two junctions must be defined–one for the conductance in each direction.","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"For example usage, see the pinskyrinzel.jl demo.","category":"page"},{"location":"core/compartments/","page":"Compartments","title":"Compartments","text":"CompartmentSystem\nMultiCompartmentSystem\nMultiCompartment","category":"page"},{"location":"core/compartments/#Conductor.CompartmentSystem","page":"Compartments","title":"Conductor.CompartmentSystem","text":"struct CompartmentSystem{T<:Conductor.CompartmentForm} <: Conductor.AbstractCompartmentSystem\n\nA neuronal compartment.\n\nform::Conductor.CompartmentForm\neqs::Vector{Symbolics.Equation}\niv::Symbolics.Num\nIndependent variable. Defaults to time, t.\nstates::Vector{Symbolics.Num}\nps::Vector{Symbolics.Num}\nobserved::Vector{Symbolics.Equation}\nname::Symbol\nsystems::Vector{ModelingToolkit.AbstractTimeDependentSystem}\ndefaults::Dict\nextensions::Vector{ModelingToolkit.ODESystem}\nAdditional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\n\nparent::Ref{Conductor.AbstractCompartmentSystem}\nReference to the parent system when the compartment is a subcompartment in a MultiCompartmentSystem.\n\n\n\n\n\n","category":"type"},{"location":"core/compartments/#Conductor.MultiCompartmentSystem","page":"Compartments","title":"Conductor.MultiCompartmentSystem","text":"struct MultiCompartmentSystem <: Conductor.AbstractCompartmentSystem\n\nA neuron with 2+ morphologically connected compartments.\n\neqs::Vector{Symbolics.Equation}\niv::Symbolics.Num\nIndependent variabe. Defaults to time, t.\nstates::Vector{Symbolics.Num}\nps::Vector{Symbolics.Num}\nobserved::Vector{Symbolics.Equation}\nname::Symbol\nsystems::Vector{ModelingToolkit.AbstractTimeDependentSystem}\ndefaults::Dict\ntopology::MultiCompartmentTopology\ncompartments::Vector{CompartmentSystem}\nIndividual subcompartments of the neuron.\nextensions::Vector{ModelingToolkit.ODESystem}\nAdditional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\n\n\n\n\n\n","category":"type"},{"location":"core/compartments/#Conductor.MultiCompartment","page":"Compartments","title":"Conductor.MultiCompartment","text":"MultiCompartment(topology; extensions, name, defaults) -> MultiCompartmentSystem\n\n\nBasic constructor for a MultiCompartmentSystem.\n\n\n\n\n\n","category":"type"},{"location":"core/networks/#Networks","page":"Networks","title":"Networks","text":"","category":"section"},{"location":"core/networks/#networks","page":"Networks","title":"NeuronalNetworkSystem","text":"","category":"section"},{"location":"core/networks/","page":"Networks","title":"Networks","text":"Population\nNeuronalNetworkSystem","category":"page"},{"location":"core/networks/#Conductor.Population","page":"Networks","title":"Conductor.Population","text":"struct Population{T<:Conductor.AbstractCompartmentSystem}\n\nAn iterable population (or small group) of neurons.\n\nA Population is a lazy representation of neurons templated from a single model prototype. Iterating over a Population returns up to n uniquely-named copies of the prototype that are serially numbered and, optionally, namespaced. Parameter values of the replicate neurons can be individually defined by indexed assignment, or applied to the entire group via distributions.\n\nproto\nThe base neuron model.\nn\nThe number of neurons in the population.\npopname\nName of the population.\ndefs\nPopulation defaults\nstimuli\nStimuli applied to select neurons.\n\n\n\n\n\n","category":"type"},{"location":"core/networks/#Conductor.NeuronalNetworkSystem","page":"Networks","title":"Conductor.NeuronalNetworkSystem","text":"struct NeuronalNetworkSystem <: Conductor.AbstractNeuronalNetworkSystem\n\nA network of neurons with synaptic connections.\n\neqs::Vector{Symbolics.Equation}\niv::Symbolics.Num\nIndependent variabe. Defaults to time, t.\nstates::Vector{Symbolics.Num}\nps::Vector{Symbolics.Num}\nobserved::Vector{Symbolics.Equation}\nname::Symbol\nsystems::Vector{ModelingToolkit.AbstractTimeDependentSystem}\ndefaults::Dict\ntopology::NetworkTopology\nreversal_map::Dict\nextensions::Vector{ModelingToolkit.ODESystem}\nAdditional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/#Overview","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Conductor.jl builds neurobiological models in a bottom-up workflow, beginning with user-defined equations. Equations may be written using primitives–declared symbolic variables that represent physical quantities like voltage, current, ion concentrations, etc.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"State dynamics in neurons are described predominately by gates, which convert arbitrary inputs into activation weights. A ConductanceSystem is comprised of one or more gates. Conductances combine the outputs of gates, producing a scalar quantity that can represent the permeability of ion channels, synaptic channels, and axial conductances between morphologically connected compartments.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Each conductance is associated with a CompartmentSystem. The properties of the parent compartment (for example, equilibrium potentials, membrane capacitance, and geometry) influence the magnitude of intracellular current produced by conductances.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Finally, connections between neurons can be explicitly defined with a NetworkTopology, which stores a multilayer graph representation of the neuronal network. A NeuronalNetworkSystem constructs and manages the equations that govern synaptic conductances between neurons.","category":"page"},{"location":"basics/#Simple-Two-Neuron-Simulation","page":"Basics","title":"Simple Two Neuron Simulation","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Here's a quick copy-paste example of two synaptically coupled neurons with Hodgkin-Huxley dynamics:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using Conductor, IfElse, OrdinaryDiffEq, Plots, Unitful, ModelingToolkit\nimport Unitful: mV, mS, cm, µm, pA, nA, mA, µA, ms, nS, pS\nimport Conductor: Na, K\n\nVₘ = MembranePotential(-65mV)\n\nnav_kinetics = [\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -40.0, 1.0, (0.1*(Vₘ + 40.0))/(1.0 - exp(-(Vₘ + 40.0)/10.0))),\n         4.0*exp(-(Vₘ + 65.0)/18.0), p = 3, name = :m)\n    Gate(AlphaBeta,\n         0.07*exp(-(Vₘ+65.0)/20.0),\n         1.0/(1.0 + exp(-(Vₘ + 35.0)/10.0)), name = :h)]\n\nkdr_kinetics = [\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -55.0, 0.1, (0.01*(Vₘ + 55.0))/(1.0 - exp(-(Vₘ + 55.0)/10.0))),\n         0.125 * exp(-(Vₘ + 65.0)/80.0),\n         p = 4, name = :n)]\n\n@named NaV = IonChannel(Sodium, nav_kinetics, max_g = 120mS/cm^2)\n@named Kdr = IonChannel(Potassium, kdr_kinetics, max_g = 36mS/cm^2)\n@named leak = IonChannel(Leak, max_g = 0.3mS/cm^2)\nreversals = Equilibria([Na => 50.0mV, K => -77.0mV, Leak => -54.4mV])\n\n@named Iₑ = IonCurrent(NonIonic)\nholding_current = Iₑ ~ ustrip(Float64, µA, 5000pA)\nchannels = [NaV, Kdr, leak];\n\ndynamics_1 = HodgkinHuxley(Vₘ, channels, reversals;\n                         geometry = Cylinder(radius = 25µm, height = 400µm),\n                         stimuli = [holding_current])\n\n@named neuron1 = Compartment(dynamics_1)\n\ndynamics_2 = HodgkinHuxley(Vₘ, channels, reversals;\n                           geometry = Cylinder(radius = 25µm, height = 400µm))\n\n@named neuron2 = Compartment(dynamics_2)\n\n# Synaptic model\nVₓ = ExtrinsicPotential()\nsyn∞ = 1/(1 + exp((-35 - Vₓ)/5))\nτsyn = (1 - syn∞)/(1/40)\nsyn_kinetics = Gate(SteadyStateTau, syn∞, τsyn, name = :z)\nEGlut = Equilibrium(Cation, 0mV, name = :Glut)\n@named Glut = SynapticChannel(Cation, [syn_kinetics]; max_s = 30nS);\n\ntopology = NetworkTopology([neuron1, neuron2], [Glut]);\nadd_synapse!(topology, neuron1, neuron2, Glut)\nreversal_map = Dict([Glut => EGlut])\n\n@named net = NeuronalNetworkSystem(topology, reversal_map)\ntotal_time = 250\nsim = Simulation(net, time = total_time*ms)\n\nsolution = solve(sim, Rosenbrock23(), abstol=1e-3, reltol=1e-3, saveat=0.2)\nplot(solution; vars=[neuron1.Vₘ, neuron2.Vₘ])","category":"page"},{"location":"basics/#Step-by-step-explanation","page":"Basics","title":"Step-by-step explanation","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"using Conductor, IfElse, OrdinaryDiffEq, Plots, Unitful, ModelingToolkit\nimport Unitful: mV, mS, cm, µm, pA, nA, mA, µA, ms, nS, pS\nimport Conductor: Na, K","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"We start by defining a primitive variable for voltage, Vₘ, which we'll use to write equations describing the kinetics of some Hodgkin-Huxley gating particles.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Vₘ = MembranePotential(-65mV)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Often the voltage- and time-dependent dynamics of ion channels are described in books and journal articles using forward, alpha, and reverse, beta, reaction rates:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"beginaligned\nalpha(V_m) = 01(V_m+40)1-e^-(V_m+40)10 \nbeta(V_m) = 4e^-(V_m+65)18\nendaligned","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"To reproduce the math, we'll define a Gate and indicate the format of our equations with a trait, AlphaBeta. We'll also use an optional keyword argument, p, which sets the exponent of the resulting gating variable (for example, p = 3 to set m^3 as found in Hodgkin-Huxley-style Sodium channels). ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"# Fast Sodium channel kinetics\nnav_kinetics = [\n    # the activation gate, m\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -40.0, 1.0, (0.1*(Vₘ + 40.0))/(1.0 - exp(-(Vₘ + 40.0)/10.0))),\n         4.0*exp(-(Vₘ + 65.0)/18.0), p = 3, name = :m)\n    # the inactivation gate, h\n    Gate(AlphaBeta,\n         0.07*exp(-(Vₘ+65.0)/20.0),\n         1.0/(1.0 + exp(-(Vₘ + 35.0)/10.0)), name = :h)]\n\n# Delayed rectifier Potassium kinetics\nkdr_kinetics = [\n    # the activation gate, n\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -55.0, 0.1, (0.01*(Vₘ + 55.0))/(1.0 - exp(-(Vₘ + 55.0)/10.0))),\n         0.125 * exp(-(Vₘ + 65.0)/80.0),\n         p = 4, name = :n)]","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\nThere's a discontinuity in the original equations, so we use IfElse.ifelse to avoid a divide-by-zero error.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Now that we've defined the gating variables, we can construct some ion channels and define a set of matching primitives representing equilibrium potentials for sodium, potassium, and non-specific leak current. ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"@named NaV = IonChannel(Sodium, nav_kinetics, max_g = 120mS/cm^2)\n@named Kdr = IonChannel(Potassium, kdr_kinetics, max_g = 36mS/cm^2)\n@named leak = IonChannel(Leak, max_g = 0.3mS/cm^2)\nreversals = Equilibria([Na => 50.0mV, K => -77.0mV, Leak => -54.4mV])","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"We also need to model current injection to stimulate spiking. We'll declare a new primitive current and use the resulting symbolic to write an equation describing what the value of the electrode current should be.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"@named Iₑ = IonCurrent(NonIonic)\nholding_current = Iₑ ~ ustrip(Float64, µA, 5000pA)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"note: Note\nConductor.jl converts all currents to µA internally, so here we use Unitful.ustrip to make sure our input is formatted appropriately.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Finally, we construct our two neurons, providing the holding current stimulus to neuron1, which will be our presynaptic neuron.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"channels = [NaV, Kdr, leak];\ndynamics_1 = HodgkinHuxley(Vₘ, channels, reversals;\n                         geometry = Cylinder(radius = 25µm, height = 400µm),\n                         stimuli = [holding_current])\n\n@named neuron1 = Compartment(dynamics_1)\n\ndynamics_2 = HodgkinHuxley(Vₘ, channels, reversals;\n                           geometry = Cylinder(radius = 25µm, height = 400µm))\n\n@named neuron2 = Compartment(dynamics_2)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"For our neurons to talk to each other, we'll need a model for a synaptic conductance. This time we'll use a model that's presented in a different form in the literature. A model of a glutamatergic excitatory synapse adapted from Prinz et al 2004:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"    beginaligned\n    s_infty(V_pre = frac11 + e^-35 - V_pre5 \n    tau_s   = frac1 - s_infty(V_pre140\n    endaligned","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"We will start by declaring a primitive, ExtrinsicPotential, which represents a voltage coming from an outside source (in this case, a presynaptic neuron). ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Vₓ = ExtrinsicPotential()","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Next, we define a Gate and indicate that our kinetic equations have the form SteadyStateTau. ","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"syn∞ = 1/(1 + exp((-35 - Vₓ)/5))\nτsyn = (1 - syn∞)/(1/40)\nsyn_kinetics = Gate(SteadyStateTau, syn∞, τsyn, name = :z)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"We'll then build a SynapticChannel and define an equilibrium potential.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"EGlut = Equilibrium(Cation, 0mV, name = :Glut)\n@named Glut = SynapticChannel(Cation, [syn_kinetics]; max_s = 30nS);","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Given our two neurons and a synaptic channel, we can model a miniature circuit by defining a synapse between the neurons and then constructing a NeuronalNetworkSystem:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"topology = NetworkTopology([neuron1, neuron2], [Glut]);\nadd_synapse!(topology, neuron1, neuron2, Glut)\nreversal_map = Dict([Glut => EGlut])\n\n@named net = NeuronalNetworkSystem(topology, reversal_map)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Now we're ready to run our simulation.","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"total_time = 250\nsim = Simulation(net, time = total_time*ms)\nsolution = solve(sim, Rosenbrock23(), abstol=1e-3, reltol=1e-3, saveat=0.2)\nplot(solution; vars=[neuron1.Vₘ, neuron2.Vₘ])","category":"page"},{"location":"core/conductances/#conductance","page":"Conductances","title":"ConductanceSystem","text":"","category":"section"},{"location":"core/conductances/","page":"Conductances","title":"Conductances","text":"A ConductanceSystem describes the state- and time-dependence of a conductance (i.e. classically g, the inverse of resistance; typically measured in Siemens). It can be used to model the conductance associated with ionic membrane currents, synaptic currents, and axial currents that flow between connected neuronal compartments. By default, a Conductance System is composed of zero or more gates and a parameter for the maximum conductance value (overlineg). The output of a ConductanceSystem is equal to the the product of each individual gate and overlineg.","category":"page"},{"location":"core/conductances/","page":"Conductances","title":"Conductances","text":"To model sodium conductance in a Hodgkin-Huxley model:","category":"page"},{"location":"core/conductances/","page":"Conductances","title":"Conductances","text":"using Conductor, ModelingToolkit, IfElse, Unitful\nimport Unitful: mV, mS, cm\n\nVₘ = MembranePotential()\n\nnav_kinetics = [\n    Gate(AlphaBeta,\n         IfElse.ifelse(Vₘ == -40.0, 1.0, (0.1*(Vₘ + 40.0))/(1.0 - exp(-(Vₘ + 40.0)/10.0))),\n         4.0*exp(-(Vₘ + 65.0)/18.0), p = 3, name = :m)\n    Gate(AlphaBeta,\n         0.07*exp(-(Vₘ+65.0)/20.0),\n         1.0/(1.0 + exp(-(Vₘ + 35.0)/10.0)), name = :h)]\n\n@named NaV = IonChannel(Sodium, nav_kinetics, max_g = 120mS/cm^2) \n@assert length(equations(NaV)) == 3; # hide\n\nequations(NaV) # includes: g(t) ~ gbar*(m(t)^3)*h(t)","category":"page"},{"location":"core/conductances/","page":"Conductances","title":"Conductances","text":"ConductanceSystem\nIonChannel\nAxialConductance\nSynapticChannel","category":"page"},{"location":"core/conductances/#Conductor.ConductanceSystem","page":"Conductances","title":"Conductor.ConductanceSystem","text":"struct ConductanceSystem <: Conductor.AbstractConductanceSystem\n\nA model of conductance.\n\neqs\niv\nIndependent variable. Defaults to time, t.\nstates\nps\nobserved\nname\nsystems\ndefaults\noutput\nConductance, g, of the system.\ngbar\nMaximum conductance, overlineg.\nion\nPermeability of the conductance.\naggregate\ngate_vars\nGating variables.\nsubscriptions\nExtrinsic sources of state (e.g. presynaptic compartments).\nextensions\nAdditional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\n\ninputs\n\n\n\n\n\n","category":"type"},{"location":"core/conductances/#Conductor.IonChannel","page":"Conductances","title":"Conductor.IonChannel","text":"IonChannel(ion, gate_vars; <keyword arguments>)\n\nAn ionic membrane conductance.\n\nArguments\n\nmax_g: Default value for maximum conductance, overlineg.\nextensions::Vector{ODESystem}: Additional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\ndefaults::Dict: Default values for states and parameters.\nname::Symbol: Name of the system.\n\n\n\n\n\n","category":"function"},{"location":"core/conductances/#Conductor.AxialConductance","page":"Conductances","title":"Conductor.AxialConductance","text":"AxialConductance(gate_vars; <keyword arguments>)\n\nA non-specific conductance between morphologically contiguous compartments.\n\nArguments\n\nmax_g: Maximum conductance, overlineg.\nextensions::Vector{ODESystem}: Additional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\ndefaults::Dict: Default values for states and parameters.\nname::Symbol: Name of the system.\n\n\n\n\n\n","category":"function"},{"location":"core/conductances/#Conductor.SynapticChannel","page":"Conductances","title":"Conductor.SynapticChannel","text":"SynapticChannel(ion, gate_vars; <keyword arguments>)\n\nA synaptically activated conductance. Depends on extrinsic (i.e. presynaptic) state.\n\nArguments\n\nmax_g: Maximum conductance, overlineg.\nextensions::Vector{ODESystem}: Additional systems to extend dynamics. Extensions are composed with the parent system during conversion to ODESystem.\naggregate::Bool: whether the Conductance model should aggregate extrinsic sources of state instead of integrating them independently. Defaults to false.\ndefaults::Dict: Default values for states and parameters.\nname::Symbol: Name of the system.\n\n\n\n\n\n","category":"function"},{"location":"#Conductor.jl","page":"Home","title":"Conductor.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Conductor.jl aims to be a platform for quickly and flexibly building high-performance, multi-scale neuronal network models in Julia. Under the hood it's being built on top of ModelingToolkit.jl–so all the tools available in the SciML and DiffEq ecosystem are (or soon will be) useable and composable with the neuronal models built here.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Conductor.jl, simply add it from the Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.7) pkg> add Conductor","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can use the following lines of Julia code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(name=\"Conductor\")","category":"page"},{"location":"core/gates/#gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"core/gates/#Overview","page":"Gates","title":"Overview","text":"","category":"section"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Gates are the most basic building block for describing dynamics in Conductor.jl. A gate integrates zero or more inputs into a single unitless weighting value. If desired, we can explicitly define the symbolic expression that models the output of a gate:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"using Conductor\n# Voltage-dependent sigmoid activation\nVₘ = MembranePotential()\n@named sigmoid = Gate(SimpleGate, inv(1 + exp(-Vₘ)))\n\n# output\nGate{SimpleGate}(SimpleGate, sigmoid(t), Symbolics.Equation[sigmoid(t) ~ 1 / (1 + exp(-Vₘ(t)))], Dict{Symbol, Any}())","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"The dynamics of a Gate{SimpleGate} are just an algebraic equation:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Conductor.get_eqs(sigmoid, nothing) # internal API call\n\n# output\n1-element Vector{Symbolics.Equation}:\n sigmoid(t) ~ 1 / (1 + exp(-Vₘ(t)))","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Alternatively, we can take advantage of customized constructors, which let us describe gate dynamics in a more canonical, domain-friendly form. For instance, in the classic Hodgkin-Huxley formalism, gates are analogous to the \"gating particles\" used to describe the kinetics of voltage-gated ion channels. In the scientific literature, ionic channel kinetics are often described in terms of forward (alpha) and reverse (beta) reaction rates:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"# Sodium channel inactivation kinetics, defined by forward and reverse rxn rates\n@named h = Gate(\n    AlphaBeta,\n    # the α (forward) reaction rate\n    0.07*exp(-(Vₘ+65.0)/20.0),\n    # the β (reverse) reaction rate\n    1.0/(1.0 + exp(-(Vₘ + 35.0)/10.0))\n)\n\n# output\nGate{AlphaBeta}(AlphaBeta, h(t), Symbolics.Equation[Differential(t)(h(t)) ~ (-h(t)) / (1.0 + exp(-3.5 - 0.1Vₘ(t))) + 0.07(1 - h(t))*exp(-3.25 - 0.05Vₘ(t))], Dict{Symbol, Any}(:ss => (0.07exp(-3.25 - 0.05Vₘ(t))) / (1.0 / (1.0 + exp(-3.5 - 0.1Vₘ(t))) + 0.07exp(-3.25 - 0.05Vₘ(t)))))\n","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Now when we ask for the dynamics of a Gate{AlphaBeta}, we get the differential form:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Conductor.get_eqs(h, nothing)\n\n# output\n1-element Vector{Symbolics.Equation}:\n Differential(t)(h(t)) ~ (-h(t)) / (1.0 + exp(-3.5 - 0.1Vₘ(t))) + 0.07(1 - h(t))*exp(-3.25 - 0.05Vₘ(t))","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"...which is the equivalent to:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"fracdhdt = alpha_h (1-h)-beta_h h","category":"page"},{"location":"core/gates/#Advanced-Gates-and-Customization","page":"Gates","title":"Advanced Gates & Customization","text":"","category":"section"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Conductor.jl provides a handful of ready-made Gate types for convenience. But gates may also be user-customized. The following must be implemented for each gate:","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Create a trait label: struct MyNewGate <: GateVarForm end\nDefine the following methods:\nConductor.Gate(::Type{MyNewGate}, ...)\nThis should return with a call to Gate{MyNewGate}(output::Num; kwargs...)\nConductor.output(gate::Gate{MyNewGate})::Num\nModelingToolkit.get_eqs(gate::Gate{MyNewGate}, compartment::AbstractCompartmentSystem)::Vector{Equation} ","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"note: Note\nKeyword arguments passed to Gate{<:GateVarType}(output::Num; kwargs...) are stored as a dictionary and can be accessed via get, getproperty or (equivalently) dot syntax (e.g. mygate.x)","category":"page"},{"location":"core/gates/","page":"Gates","title":"Gates","text":"Conductor.GateVarForm\nGate\nConductor.get_eqs","category":"page"},{"location":"core/gates/#Conductor.GateVarForm","page":"Gates","title":"Conductor.GateVarForm","text":"abstract type GateVarForm\n\nAbstract supertype for extending the behavior of Gate.\n\nStub subtypes of GateVarForm are used as traits when writing new methods that call Gate objects.\n\nExample\n\nstruct MyNewGate <: Conductor.GateVarForm end\n\nfunction Conductor.get_eqs(g::Gate{MyNewGate}, comp::CompartmentSystem)\n    # a function that returns a vector of equations defining gate dynamics\nend\n\n\n\n\n\n","category":"type"},{"location":"core/gates/#Conductor.Gate","page":"Gates","title":"Conductor.Gate","text":"struct Gate{T<:Conductor.GateVarForm} <: Conductor.AbstractGatingVariable\n\nLow-level constructor for Gate.\n\nA gate has a single symbolic output and stores properties (passed as a variable length list of keyword arguments). Gate properties are accessible via get and getproperty.\n\nExample\n\njulia> @variables t X(t)\n2-element Vector{Num}:\n    t\n X(t)\n\njulia> g = Gate{MyGateType}(MyGateType, X, Equation[], prop1 = \"foo\", prop2 = 62)\nGate{MyGateType}(MyGateType, X(t), Symbolics.Equation[], Dict{Symbol, Any}(:prop2 => 62, :prop1 => \"foo\"))\n\njulia> (g.prop1, g.prop2)\n(\"foo\", 62)\n\n\n\n\n\nGate(form::Type{AlphaBeta}, α, β; name, kwargs...) -> Gate{AlphaBeta}\n\n\nAccepts expressions for forward (α) and reverse (β) reaction rates as descriptors for its kinetics.\n\nSee also: get_eqs.\n\n\n\n\n\nGate(form::Type{SteadyStateTau}, x∞, τₓ; name, kwargs...) -> Gate{SteadyStateTau}\n\n\nAccepts expressions for its steady-state activation, x∞(Vₘ), and the time constant, τₓ(Vₘ), as descriptors for its kinetics.\n\nSee also: get_eqs.\n\n\n\n\n\nGate(form::Type{SimpleGate}, rhs; default, name, kwargs...) -> Gate{SimpleGate}\n\n\nAccepts any symbolic expression as an explicit definition of the gate dynamics.\n\n\n\n\n\nGate(form::Type{Conductor.ParameterGate}, val; name, kwargs...) -> Gate{Conductor.ParameterGate}\n\n\nA static parameter gate with initial value, val.\n\n\n\n\n\nGate(::Type{HeavisideSum}; threshold = 0mV, decay = 150, name = Base.gensym(\"GateVar\") [, saturation])\n\nSynaptically-activated dynamics. Sums the step-function values for presynaptic (extrinsic) voltages.\n\nThe optional argument saturation sets a upper limit on the value of this gate.\n\nSee also: get_eqs.\n\n\n\n\n\n","category":"type"},{"location":"core/gates/#ModelingToolkit.get_eqs","page":"Gates","title":"ModelingToolkit.get_eqs","text":"get_eqs(var::Gate{HeavisideSum}, chan)\n\nReturns an equation of the form:\n\nfracdxdt=displaystyle sum_jHeaviside(V_j-threshold)-xsaturation\n\n\n\n\n\n","category":"function"},{"location":"core/primitives/#Constants-and-Primitives","page":"Primitives","title":"Constants & Primitives","text":"","category":"section"},{"location":"core/primitives/#primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"core/primitives/","page":"Primitives","title":"Primitives","text":"Primitives are special symbolic variables that are annotated with additional domain-specific metadata. Conductor.jl uses primitives found in user-defined equations to validate models and improve code generation.","category":"page"},{"location":"core/primitives/","page":"Primitives","title":"Primitives","text":"MembranePotential\nExtrinsicPotential\nIonConcentration\nIonCurrent\nEquilibriumPotential","category":"page"},{"location":"core/primitives/#Conductor.MembranePotential","page":"Primitives","title":"Conductor.MembranePotential","text":"MembranePotential(V0 = -60mV; <keyword arguments>)\n\nThe voltage in an arbitrary compartment.\n\nIf V0 == nothing, the default value of the resulting variable will be left unassigned.\n\nArguments\n\ndynamic::Bool = true: when false, the voltage will be a static parameter.\nsource::PrimitiveSource = Intrinsic: the expected origin of a voltage state. Intrinsic sources are states from the parent compartment. Extrinsic sources come from other compartments (e.g. presynaptic compartments).\nn::Integer = 1: when n > 1, the voltage will be a symbolic array of length n.\nname::Symbol = :Vₘ: the symbol to use for the symbolic variable\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Conductor.ExtrinsicPotential","page":"Primitives","title":"Conductor.ExtrinsicPotential","text":"ExtrinsicPotential(; n = 1, name::Symbol = :Vₓ)\n\nA voltage derived from an external source (i.e. not the parent compartment).\n\nEquivalent to: MembranePotential(nothing; dynamic=true, source=Extrinsic, n=n, name=name)\n\nArguments\n\nn::Integer = 1: when n > 1, the voltage will be a symbolic array of length n.\nname::Symbol = :Vₓ: the symbol to use for the symbolic variable\n\n\n\n\n\n","category":"function"},{"location":"core/primitives/#Conductor.IonConcentration","page":"Primitives","title":"Conductor.IonConcentration","text":"IonConcentration(ion::IonSpecies, val = nothing; <keyword arguments>)\n\nAn intra/extracellular concentration of ions.\n\nArguments\n\nlocation::PrimitiveLocation = Inside: location (Inside or Outside) w.r.t. the parent compartment (intracellular or extracellular).\ndynamic::Bool = false: when false, the concentration will be a static parameter.\nname::Symbol = Conductor.PERIODIC_SYMBOL[ion]: the symbol to use for the symbolic variable. By default, a lookup table is used to find the ion's symbol on the periodic table of elements.\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Conductor.IonCurrent","page":"Primitives","title":"Conductor.IonCurrent","text":"IonCurrent(ion::IonSpecies, val = nothing; <keyword arguments>)\n\nAn ionic membrane current.\n\nArguments\n\naggregate::Bool = false: aggregate currents are the sum of all conductances (with  matched ion species) flowing into the parent compartment. For example, an aggregate  IonCurrent for Calcium will be the sum of all other Calcium-permeable currents.\ndynamic::Bool = true: when dynamic == false the IonCurrent will be a static  parameter value.\nname::Symbol = Symbol(\"I\", Conductor.PERIODIC_SYMBOL[ion]): the symbol to use for the  symbolic variable. By default, a lookup table is used to find the ion's symbol on the  periodic table of elements.\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Conductor.EquilibriumPotential","page":"Primitives","title":"Conductor.EquilibriumPotential","text":"EquilibriumPotential(ion::IonSpecies, val; <keyword arguments>)\n\nAn equilibrium (a.k.a. reversal) potential.\n\nArguments\n\ndynamic::Bool = false: a dynamic EquilbriumPotential is assumed to vary with time (e.g. derived from the Nernst equation).\nname::Symbol = Symbol(\"I\", Conductor.PERIODIC_SYMBOL[ion]): the symbol to use for the  symbolic variable. By default, a lookup table is used to find the ion's symbol on the  periodic table of elements.\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Constants","page":"Primitives","title":"Constants","text":"","category":"section"},{"location":"core/primitives/","page":"Primitives","title":"Primitives","text":"Conductor.t\nConductor.D\nConductor.ℱ\nConductor.IonSpecies","category":"page"},{"location":"core/primitives/#Conductor.t","page":"Primitives","title":"Conductor.t","text":"The independent variable for time, t.\n\n\n\n\n\n","category":"constant"},{"location":"core/primitives/#Conductor.D","page":"Primitives","title":"Conductor.D","text":"Differential with respect to time, t.\n\n\n\n\n\n","category":"function"},{"location":"core/primitives/#Conductor.ℱ","page":"Primitives","title":"Conductor.ℱ","text":"Faraday's Constant\n\nThe electric charge of one mole of electrons.\n\nUnicode ℱ can be typed by writing \\scrF then pressing tab in the Julia REPL, and in many editors.\n\nExamples\n\njulia> Conductor.ℱ\n96485.33212331001 C mol^-1\n\n\n\n\n\n","category":"constant"},{"location":"core/primitives/#Conductor.IonSpecies","page":"Primitives","title":"Conductor.IonSpecies","text":"Ion species to annotate ConductanceSystem, IonCurrent, IonConcentration, etc. May be one of:\n\nNonIonic\nSodium\nPotassium\nChloride\nCalcium\nCation\nAnion\nGlutamatergic\nCholinergic\nAMPA\nNMDA\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Quantities","page":"Primitives","title":"Quantities","text":"","category":"section"},{"location":"core/primitives/","page":"Primitives","title":"Primitives","text":"In addition, Conductor.jl defines the following useful Unitful.jl-compatible units:","category":"page"},{"location":"core/primitives/","page":"Primitives","title":"Primitives","text":"Conductor.SpecificConductance\nConductor.SpecificCapacitance","category":"page"},{"location":"core/primitives/#Conductor.SpecificConductance","page":"Primitives","title":"Conductor.SpecificConductance","text":"Conductance per unit area.\n\n\n\n\n\n","category":"type"},{"location":"core/primitives/#Conductor.SpecificCapacitance","page":"Primitives","title":"Conductor.SpecificCapacitance","text":"Capacitance per unit area.\n\n\n\n\n\n","category":"type"}]
}
